// ViewModels/ShapeEditorViewModel.cs
using System.Collections.ObjectModel;
using APS_Optimizer_V3.Helpers;
using System.Diagnostics;
using APS_Optimizer_V3.Services;

namespace APS_Optimizer_V3.ViewModels;
public partial class ShapeEditorViewModel : ViewModelBase
{
    // --- Properties for UI Binding ---
    [ObservableProperty] private string _shapeName = "New Shape";
    [ObservableProperty] private int _editorGridWidth = 3;
    [ObservableProperty] private int _editorGridHeight = 3;
    // List of available types for the editor UI
    // Could be ObservableCollection if types might change dynamically
    public List<CellTypeInfo> AvailableCellTypes { get; } = GetEditorCellTypes();

    [ObservableProperty]
    private CellType _selectedCellType = CellType.Generic;

    // --- Internal state for the pattern ---
    private CellType[,] _currentPattern = new CellType[3, 3]; // Initialize with default size & Empty
    // --------------------------------------
    private const double EditorCellSize = 20.0;
    private const double EditorCellSpacing = 1.0;

    private readonly ShapeViewModel? _originalShapeViewModel;
    public bool IsEditing => _originalShapeViewModel != null;

    // --- Constructors ---
    public ShapeEditorViewModel() // Adding new shape
    {
        _originalShapeViewModel = null;
        // Initialize pattern with correct dimensions and Empty type
        _currentPattern = new CellType[EditorGridHeight, EditorGridWidth];
        RebuildEditorCellsFromPattern();
    }

    public ShapeEditorViewModel(ShapeViewModel shapeToEdit) // Editing existing shape
    {
        _originalShapeViewModel = shapeToEdit;
        ShapeName = shapeToEdit.Name;
        CellType[,] basePattern = shapeToEdit.GetBaseRotationGrid();

        // Set fields directly first
        _editorGridHeight = basePattern.GetLength(0);
        _editorGridWidth = basePattern.GetLength(1);
        _currentPattern = (CellType[,])basePattern.Clone();

        // Notify UI about initial size changes (important!)
        OnPropertyChanged(nameof(EditorGridHeight));
        OnPropertyChanged(nameof(EditorGridWidth));
        OnPropertyChanged(nameof(CalculatedEditorGridWidth));

        RebuildEditorCellsFromPattern();
    }

    // --- Property Change Handlers (Generated by [ObservableProperty]) ---
    partial void OnEditorGridWidthChanged(int value)
    {
        ResizePattern(EditorGridHeight, value); // Use new width
        OnPropertyChanged(nameof(CalculatedEditorGridWidth));
        RebuildEditorCellsFromPattern();
    }

    partial void OnEditorGridHeightChanged(int value)
    {
        ResizePattern(value, EditorGridWidth); // Use new height
        RebuildEditorCellsFromPattern();
    }

    private static List<CellTypeInfo> GetEditorCellTypes()
    {
        return new List<CellTypeInfo>
        {
            new CellTypeInfo(CellType.Generic, "Generic", "Assets/Icons/generic.png"), // Placeholder paths
            new CellTypeInfo(CellType.Loader, "Loader", "Assets/Icons/loader.png"),
            new CellTypeInfo(CellType.ClipN, "Clip N", "Assets/Icons/clip_n.png"),
            new CellTypeInfo(CellType.ClipE, "Clip E", "Assets/Icons/clip_e.png"),
            new CellTypeInfo(CellType.ClipS, "Clip S", "Assets/Icons/clip_s.png"),
            new CellTypeInfo(CellType.ClipW, "Clip W", "Assets/Icons/clip_w.png"),
            new CellTypeInfo(CellType.Cooler, "Cooler", "Assets/Icons/cooler.png"),
            new CellTypeInfo(CellType.Empty, "Eraser", "Assets/Icons/eraser.png") // Use Empty type for eraser
        };
    }

    // *** CHANGE: Resize logic for CellType[,] ***
    private void ResizePattern(int newHeight, int newWidth)
    {
        if (newHeight <= 0 || newWidth <= 0) return; // Invalid size

        CellType[,] oldPattern = _currentPattern;
        CellType[,] newPattern = new CellType[newHeight, newWidth]; // Defaults to Empty

        int rowsToCopy = Math.Min(newHeight, oldPattern.GetLength(0));
        int colsToCopy = Math.Min(newWidth, oldPattern.GetLength(1));

        for (int r = 0; r < rowsToCopy; r++)
        {
            for (int c = 0; c < colsToCopy; c++)
            {
                newPattern[r, c] = oldPattern[r, c];
            }
        }
        _currentPattern = newPattern;
    }



    // --- Properties for UI Binding ---

    public double CalculatedEditorGridWidth
    {
        get
        {
            if (EditorGridWidth <= 0) return EditorCellSize;
            double calculated = (EditorGridWidth * EditorCellSize) + ((Math.Max(0, EditorGridWidth - 1)) * EditorCellSpacing);
            return calculated + 1; // Add a small fraction
        }
    }

    public ObservableCollection<CellViewModel> EditorCells { get; } = new();

    // Rebuilds the entire EditorCells collection based on _currentPattern
    // *** CHANGE: Rebuild uses CellType ***
    private void RebuildEditorCellsFromPattern()
    {
        EditorCells.Clear();
        if (EditorGridWidth <= 0 || EditorGridHeight <= 0) return;
        for (int r = 0; r < EditorGridHeight; r++)
        {
            for (int c = 0; c < EditorGridWidth; c++)
            {
                CellType initialType = (r < _currentPattern.GetLength(0) && c < _currentPattern.GetLength(1))
                                     ? _currentPattern[r, c] : CellType.Empty;
                // *** Use correct constructor for Editor ***
                EditorCells.Add(new CellViewModel(r, c, HandleEditorCellClick, initialType));
            }
        }
        // OnPropertyChanged(nameof(CalculatedEditorGridWidth)); // Already notified in size change handler
    }


    private void HandleEditorCellClick(CellViewModel cell)
    {
        // Check bounds against the current UI grid dimensions
        if (cell.Row < EditorGridHeight && cell.Col < EditorGridWidth)
        {
            // Also check bounds against the internal pattern before modifying
            if (cell.Row < _currentPattern.GetLength(0) && cell.Col < _currentPattern.GetLength(1))
            {
                // Assign the currently selected type (could be Empty for eraser)
                CellType typeToAssign = SelectedCellType;

                // Optional: If clicking the same type again, maybe erase it?
                // if (_currentPattern[cell.Row, cell.Col] == typeToAssign && typeToAssign != CellType.Empty)
                // {
                //     typeToAssign = CellType.Empty;
                // }

                // Update internal pattern FIRST
                _currentPattern[cell.Row, cell.Col] = typeToAssign;

                // THEN update the cell's visual state via its Type property
                cell.Type = typeToAssign;

                Debug.WriteLine($"Editor Cell ({cell.Row},{cell.Col}) type changed to: {cell.Type}");
            }
            else { /* Log warning: Clicked outside pattern bounds */ }
        }
        else { /* Log warning: Clicked outside UI grid bounds */ }
    }


    // *** CHANGE: Get pattern returns CellType[,] and trims ***
    public CellType[,] GetCurrentPattern()
    {
        // Create a pattern matching the current editor dimensions
        CellType[,] patternToTrim = new CellType[EditorGridHeight, EditorGridWidth];
        int rows = Math.Min(EditorGridHeight, _currentPattern.GetLength(0));
        int cols = Math.Min(EditorGridWidth, _currentPattern.GetLength(1));
        for (int r = 0; r < rows; r++)
        {
            for (int c = 0; c < cols; c++)
            {
                patternToTrim[r, c] = _currentPattern[r, c];
            }
        }
        return TrimPattern(patternToTrim);
    }

    // *** CHANGE: Trim works with CellType.Empty ***
    private CellType[,] TrimPattern(CellType[,] pattern)
    {
        if (pattern.Length == 0) return pattern;
        int minRow = pattern.GetLength(0), maxRow = -1, minCol = pattern.GetLength(1), maxCol = -1;
        bool foundCell = false;
        for (int r = 0; r < pattern.GetLength(0); r++)
        {
            for (int c = 0; c < pattern.GetLength(1); c++)
            {
                if (pattern[r, c] != CellType.Empty) // Check against Empty
                {
                    minRow = Math.Min(minRow, r); maxRow = Math.Max(maxRow, r);
                    minCol = Math.Min(minCol, c); maxCol = Math.Max(maxCol, c);
                    foundCell = true;
                }
            }
        }

        if (!foundCell) return new CellType[0, 0]; // Empty pattern

        int newHeight = maxRow - minRow + 1;
        int newWidth = maxCol - minCol + 1;
        CellType[,] trimmed = new CellType[newHeight, newWidth];
        for (int r = 0; r < newHeight; r++)
        {
            for (int c = 0; c < newWidth; c++)
            {
                trimmed[r, c] = pattern[minRow + r, minCol + c];
            }
        }
        return trimmed;
    }

    [RelayCommand]
    private void SelectCellType(CellType type)
    {
        SelectedCellType = type;
        Debug.WriteLine($"Selected cell type for drawing: {SelectedCellType}");
    }
}

// *** ADD HELPER CLASS for binding RadioButtons ***
public class CellTypeInfo
{
    public CellType Type { get; }
    public string DisplayName { get; }
    public string IconPath { get; } // Path to icon for UI

    public CellTypeInfo(CellType type, string displayName, string iconPath)
    {
        Type = type;
        DisplayName = displayName;
        IconPath = iconPath; // You'll need actual icon assets
    }
}