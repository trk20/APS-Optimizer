// ViewModels/ShapeEditorViewModel.cs
using System.Collections.ObjectModel;
using APS_Optimizer_V3.Helpers;
using System.Diagnostics;
using APS_Optimizer_V3.Services;

namespace APS_Optimizer_V3.ViewModels;
public partial class ShapeEditorViewModel : ViewModelBase
{
    // --- Properties for UI Binding ---
    [ObservableProperty] private string _shapeName = "New Shape";
    [ObservableProperty] private int _editorGridWidth = 3;
    [ObservableProperty] private int _editorGridHeight = 3;
    // List of available types for the editor UI
    // Could be ObservableCollection if types might change dynamically
    public List<CellTypeInfo> AvailableCellTypes { get; } = GetEditorCellTypes();

    [ObservableProperty]
    private CellTypeInfo _selectedCellType = CellTypeInfo.GenericCellType;

    // --- Internal state for the pattern ---
    private CellTypeInfo[,] _currentPattern = new CellTypeInfo[3, 3]; // Initialize with default size & Empty
    // --------------------------------------
    private const double EditorCellSize = 20.0;
    private const double EditorCellSpacing = 1.0;

    private readonly ShapeViewModel? _originalShapeViewModel;
    public bool IsEditing => _originalShapeViewModel != null;

    // --- Constructors ---
    public ShapeEditorViewModel() // Adding new shape
    {
        _originalShapeViewModel = null;
        // Initialize pattern with correct dimensions and Empty type
        _currentPattern = new CellTypeInfo[EditorGridHeight, EditorGridWidth];
    }

    public ShapeEditorViewModel(ShapeViewModel shapeToEdit) // Editing existing shape
    {
        _originalShapeViewModel = shapeToEdit;
        ShapeName = shapeToEdit.Name;
        CellTypeInfo[,] basePattern = shapeToEdit.GetCurrentRotationGrid();

        // Set fields directly first
        _editorGridHeight = basePattern.GetLength(0);
        _editorGridWidth = basePattern.GetLength(1);
        _currentPattern = (CellTypeInfo[,])basePattern.Clone();

        // Notify UI about initial size changes (important!)
        OnPropertyChanged(nameof(EditorGridHeight));
        OnPropertyChanged(nameof(EditorGridWidth));
        OnPropertyChanged(nameof(CalculatedEditorGridWidth));
    }

    // --- Property Change Handlers (Generated by [ObservableProperty]) ---
    partial void OnEditorGridWidthChanged(int value)
    {
        ResizePattern(EditorGridHeight, value); // Use new width
        OnPropertyChanged(nameof(CalculatedEditorGridWidth));
    }

    partial void OnEditorGridHeightChanged(int value)
    {
        ResizePattern(value, EditorGridWidth); // Use new height
    }

    private static List<CellTypeInfo> GetEditorCellTypes()
    {
        return new List<CellTypeInfo>
        {
            CellTypeInfo.GenericCellType,
            CellTypeInfo.EmptyCellType,
            CellTypeInfo.BlockedCellType,
            CellTypeInfo.LoaderCellType,
            CellTypeInfo.ClipCellType,
            CellTypeInfo.CoolerCellType
        };
    }

    // *** CHANGE: Resize logic for CellType[,] ***
    private void ResizePattern(int newHeight, int newWidth)
    {
        if (newHeight <= 0 || newWidth <= 0) return; // Invalid size

        CellTypeInfo[,] oldPattern = _currentPattern;
        CellTypeInfo[,] newPattern = new CellTypeInfo[newHeight, newWidth]; // Defaults to Empty

        int rowsToCopy = Math.Min(newHeight, oldPattern.GetLength(0));
        int colsToCopy = Math.Min(newWidth, oldPattern.GetLength(1));

        for (int r = 0; r < rowsToCopy; r++)
        {
            for (int c = 0; c < colsToCopy; c++)
            {
                newPattern[r, c] = oldPattern[r, c];
            }
        }
        _currentPattern = newPattern;
    }



    // --- Properties for UI Binding ---

    public double CalculatedEditorGridWidth
    {
        get
        {
            if (EditorGridWidth <= 0) return EditorCellSize;
            double calculated = (EditorGridWidth * EditorCellSize) + ((Math.Max(0, EditorGridWidth - 1)) * EditorCellSpacing);
            return calculated + 1; // Add a small fraction
        }
    }

    public ObservableCollection<CellViewModel> EditorCells { get; } = new();

    // Rebuilds the entire EditorCells collection based on _currentPattern
    // *** CHANGE: Rebuild uses CellType ***






    // *** CHANGE: Get pattern returns CellType[,] and trims ***
    public CellTypeInfo[,] GetCurrentPattern()
    {
        // Create a pattern matching the current editor dimensions
        CellTypeInfo[,] patternToTrim = new CellTypeInfo[EditorGridHeight, EditorGridWidth];
        int rows = Math.Min(EditorGridHeight, _currentPattern.GetLength(0));
        int cols = Math.Min(EditorGridWidth, _currentPattern.GetLength(1));
        for (int r = 0; r < rows; r++)
        {
            for (int c = 0; c < cols; c++)
            {
                // patternToTrim[r, c] = _currentPattern[r, c];
            }
        }
        return TrimPattern(patternToTrim);
    }

    // *** CHANGE: Trim works with CellType.Empty ***
    private CellTypeInfo[,] TrimPattern(CellTypeInfo[,] pattern)
    {
        if (pattern.Length == 0) return pattern;
        int minRow = pattern.GetLength(0), maxRow = -1, minCol = pattern.GetLength(1), maxCol = -1;
        bool foundCell = false;
        for (int r = 0; r < pattern.GetLength(0); r++)
        {
            for (int c = 0; c < pattern.GetLength(1); c++)
            {
                if (pattern[r, c] != CellTypeInfo.EmptyCellType) // Check against Empty
                {
                    minRow = Math.Min(minRow, r); maxRow = Math.Max(maxRow, r);
                    minCol = Math.Min(minCol, c); maxCol = Math.Max(maxCol, c);
                    foundCell = true;
                }
            }
        }

        if (!foundCell) return new CellTypeInfo[0, 0]; // Empty pattern

        int newHeight = maxRow - minRow + 1;
        int newWidth = maxCol - minCol + 1;
        CellTypeInfo[,] trimmed = new CellTypeInfo[newHeight, newWidth];
        for (int r = 0; r < newHeight; r++)
        {
            for (int c = 0; c < newWidth; c++)
            {
                trimmed[r, c] = pattern[minRow + r, minCol + c];
            }
        }
        return trimmed;
    }

    [RelayCommand]
    private void SelectCellType(CellTypeInfo type)
    {
        //SelectedCellType = type;
        Debug.WriteLine($"Selected cell type for drawing: {SelectedCellType}");
    }
}